<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Thomas Hegghammer" />


<title>Basic usage</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Basic usage</h1>
<h4 class="author">Thomas Hegghammer</h4>



<p><em>Last updated 10 February 2024</em><br />
<br />
</p>
<p><code>daiR</code> has many different functionalities, but the core
one is to provide access to the Google Document AI API so you can OCR
your documents. That procedure is fairly straightforward: you make a
processing call with either <code>dai_sync()</code> or
<code>dai_async()</code> – depending on whether you want synchronous or
asynchronous processing – and then you retrieve the plaintext with
<code>get_text()</code>.</p>
<div id="synchronous-processing" class="section level2">
<h2>Synchronous processing</h2>
<p>The quickest and easiest way to OCR with Document AI (DAI) is through
synchronous processing. You simply pass an image file or a pdf (of up to
5 pages) to the processor and get the result into your R environment
within seconds.</p>
<p>We can try with a sample pdf from the CIA’s Freedom of Information
Act Electronic Reading Room:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(daiR)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">setwd</span>(<span class="fu">tempdir</span>())</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>url <span class="ot">&lt;-</span> <span class="st">&quot;https://www.cia.gov/readingroom/docs/AGH%2C%20LASLO_0011.pdf&quot;</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="fu">download.file</span>(url, <span class="st">&quot;CIA.pdf&quot;</span>)</span></code></pre></div>
<p>We send it to Document AI with <code>dai_sync()</code> and store the
HTTP response in an object.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>resp <span class="ot">&lt;-</span> <span class="fu">dai_sync</span>(<span class="st">&quot;CIA.pdf&quot;</span>)</span></code></pre></div>
<p>We then pass the response object to <code>get_text()</code>, which
extracts the text identified by Document AI.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">get_text</span>(resp)</span></code></pre></div>
<p>What if we have many documents? <code>dai_sync()</code> is not
vectorized, but you can iterate with it over vectors of filepaths. For
the sake of illustration, let’s download a second PDF.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>url <span class="ot">&lt;-</span> <span class="st">&quot;https://www.cia.gov/readingroom/docs/1956-11-26.pdf&quot;</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="fu">download.file</span>(url, <span class="st">&quot;CIA2.pdf&quot;</span>)</span></code></pre></div>
<p>We now want to apply the functions <code>dai_sync()</code> and
<code>get_text()</code> iteratively over the files <code>CIA.pdf</code>
and <code>CIA2.pdf</code>. In such cases you probably want to preserve
the extracted text in <code>.txt</code> files along the way. You can do
this by setting the parameter <code>save_to_file</code> in
<code>get_text()</code> to TRUE. This function also has a parameter
<code>outfile_stem</code> which allows you to specify the namestem of
the <code>.txt</code> file. We can get the stem from each file by
combining <code>fs::path_ext_remove()</code> and
<code>basename()</code>.</p>
<p>I further recommend adding a small pause so as not to run into rate
limit issues. A print statement is also useful for keeping track of
where you are in case of an error or interruption. A sample script might
thus look like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="do">## NOT RUN</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>myfiles <span class="ot">&lt;-</span> <span class="fu">list.files</span>(<span class="at">pattern =</span> <span class="st">&quot;*.pdf&quot;</span>)</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_along</span>(myfiles)) {</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>  <span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">&quot;Processing file&quot;</span>, i, <span class="st">&quot;of&quot;</span>, <span class="fu">length</span>(myfiles)))</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>  resp <span class="ot">&lt;-</span> <span class="fu">dai_sync</span>(myfiles[i])</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>  stem <span class="ot">&lt;-</span> fs<span class="sc">::</span><span class="fu">path_ext_remove</span>(<span class="fu">basename</span>(myfiles[i]))</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>  <span class="fu">get_text</span>(resp, <span class="at">save_to_file =</span> <span class="cn">TRUE</span>, <span class="at">outfile_stem =</span> stem)</span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>  <span class="fu">Sys.sleep</span>(<span class="dv">2</span>)</span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>}</span></code></pre></div>
<p>If you now run <code>list.files()</code>, you will see that the code
generated two files named <code>CIA.txt</code> and <code>CIA2.txt</code>
respectively.</p>
<p>Synchronous processing is very convenient, but has two limitations.
One is that OCR accuracy may be slightly reduced compared with
asynchronous processing, because <code>dai_sync()</code> converts the
source file to a lightweight, grayscale image before passing it to DAI.
The other is scaling; If you have a large pdf or many files, it is
usually preferable to process them asynchronously.</p>
</div>
<div id="asynchronous-processing" class="section level2">
<h2>Asynchronous processing</h2>
<p>In asynchronous (offline) processing, you don’t send DAI the actual
document, but rather its location on Google Storage so that DAI can
process it “in its own time”. While slightly slower than synchronous
OCR, it allows for batch processing and makes the process less
vulnerable to interruptions (like laptop battery death or inadvertent
closing of your console). Unlike <code>dai_sync</code>,
<code>dai_async()</code> is vectorized, so you can send multiple files
with a single call.</p>
<p>The first step is to use the package <code>googleCloudStorageR</code>
to upload the source file(s) to a Google Storage bucket where DAI can
find them. The following assumes that you have already configured Google
Storage and set up a default bucket as described in <a href="https://dair.info/articles/gcs_storage.html">this
vignette</a>.</p>
<p>Let’s upload our two CIA documents. I am assuming the filepaths are
still stored in the vector <code>myfiles</code> we created earlier.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="fu">library</span>(googleCloudStorageR)</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="fu">library</span>(purrr)</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="fu">map</span>(myfiles, gcs_upload)</span></code></pre></div>
<p>Let’s check that our files made it safely:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>contents <span class="ot">&lt;-</span> <span class="fu">gcs_list_objects</span>()</span></code></pre></div>
<p>We can now use <code>dai_async()</code> to tell Document AI to
process these files. At this stage it is crucial to know that
<code>dai_async()</code> takes as its main argument the <em>filenames in
the bucket</em>, NOT the filenames or -paths on your local drive. In
this particular example there is no difference, but that is not always
the case. A common error scenario is when you use a vector of full local
filepaths
(e.g. <code>files &lt;- c(&quot;/path/to/file1.pdf&quot;, &quot;/path/to/file2.pdf&quot;)</code>)
to upload the files, saving them there with their basenames
(<code>file1.pdf</code> and <code>file2.pdf</code>). When you then try
to pass the same vector to <code>dai_sync()</code>, the processing fails
because Document AI cannot find <code>/path/to/file1.pdf</code> in the
bucket, only <code>file1.pdf</code>.</p>
<p>It is therefore good practice to use the output of
<code>gcs_list_objects()</code> to create the vector that you pass to
<code>dai_async</code>. From the <a href="https://dair.info/articles/gcs_storage.html">vignette</a> on
Google Storage, we remember that if we store the output of
<code>gcs_list_objects()</code> in a dataframe named
<code>contents</code>, the filenames will be in
<code>contents$name</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>resp <span class="ot">&lt;-</span> <span class="fu">dai_async</span>(contents<span class="sc">$</span>name)</span></code></pre></div>
<p>If your call returned “status: 200”, it was accepted by the API. Note
that this does NOT mean that the processing itself was successful, only
that the request went through. For example, if there are errors in your
filepaths, DAI will create empty JSON files in the folder you provided.
If you see JSON files of around 70 bytes each in the destination folder,
you know there was something wrong with your filenames. Other things too
can cause the processing to fail, for example a corrupt file or a format
that DAI cannot handle.</p>
<p>You can check the status of a job with <code>dai_status()</code>.
Just pass the response object from your <code>dai_async()</code> call
into the parentheses, like so:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">dai_status</span>(resp)</span></code></pre></div>
<p>This will tell you whether the job is “RUNNING”, “FAILED”, or
“SUCCEEDED”. It won’t tell you how much time remains, but in my
experience, processing takes about 5-20 seconds per page. To find out
when it’s done, you can either rerun <code>dai_status()</code> till it
says “SUCCEEDED”, or you can use the function <code>dai_notify()</code>,
which will check the status for you in the background and beep when the
job is finished.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">dai_notify</span>(resp)</span></code></pre></div>
<p>When the processing is done, there will be JSON output files waiting
for you in the bucket. Let’s take a look.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>contents <span class="ot">&lt;-</span> <span class="fu">gcs_list_objects</span>()</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>contents</span></code></pre></div>
<p>Output file names look cryptic, but there’s a logic to them, namely:
<code>&quot;&lt;job_number&gt;/&lt;document_number&gt;/&lt;filename&gt;-&lt;shard_number&gt;.json&quot;</code>.
Our file will thus take the form
<code>&quot;&lt;job_number&gt;/0/CIA-0.json&quot;</code>, with
<code>&lt;job_number&gt;</code> changing from one processing call to the
next.</p>
<p>These JSON files contain the extracted text plus a wealth of other
data, such as the location of each word on the page and a binary version
of the original image. In order to get to this information we need to
download them to our local drive. Because these output files have
unpredictable names, it is often easiest to simply search for all files
ending in <code>*.json</code> using <code>grep()</code> or
<code>stringr::str_detect()</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>jsons <span class="ot">&lt;-</span> <span class="fu">grep</span>(<span class="st">&quot;*.json$&quot;</span>, contents<span class="sc">$</span>name, <span class="at">value =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>We can then download them with <code>gcs_get_object()</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">map</span>(jsons, <span class="sc">~</span> <span class="fu">gcs_get_object</span>(.x, <span class="at">saveToDisk =</span> <span class="fu">basename</span>(.x)))</span></code></pre></div>
<p>If you now run <code>list.files()</code> again, you should see
<code>CIA-0.json</code> and <code>CIA2-0.json</code> in our working
directory.</p>
<p>To get the text from a DAI JSON file, we can use
<code>get_text()</code>, but we have to specify
<code>type = &quot;async&quot;</code> so that the function knows it is being
served a JSON file and not a response object.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">get_text</span>(<span class="st">&quot;CIA-0.json&quot;</span>, <span class="at">type =</span> <span class="st">&quot;async&quot;</span>)</span></code></pre></div>
<p>To get the text from several JSON files, we just iterate over them,
setting <code>save_to_file</code> to TRUE. Unlike in the
<code>dai_sync()</code> earlier, we don’t need to specify
<code>outfile_stem</code>, because <code>get_text()</code> has the names
of the JSON files and uses their stems to create the
<code>.txt</code>s.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>local_jsons <span class="ot">&lt;-</span> <span class="fu">list.files</span>(<span class="at">pattern =</span> <span class="st">&quot;*.json&quot;</span>)</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="fu">map</span>(local_jsons, <span class="sc">~</span> <span class="fu">get_text</span>(.x, <span class="at">type =</span> <span class="st">&quot;async&quot;</span>, <span class="at">save_to_file =</span> <span class="cn">TRUE</span>))</span></code></pre></div>
<p>Running <code>list.files()</code> one last time, you should have two
new files named <code>CIA-0.txt</code> and <code>CIA2-0.txt</code>.</p>
</div>
<div id="large-batches" class="section level1">
<h1>Large batches</h1>
<p>Although <code>dai_async()</code> takes batches of files, it is
constrained by Google’s <a href="https://cloud.google.com/document-ai/quotas">rate limits</a>.
Currently, a <code>dai_async()</code> call can contain maximum 50 files
(a multi-page pdf counts as one file), and you can not have more than 5
batch requests and 10 000 pages undergoing processing at any one
time.</p>
<p>Therefore, if you’re looking to process a large batch, you need to
spread the <code>dai_async()</code> calls out over time. While you can
split up your corpus into sets of 50 files and batch process those, the
simplest solution is to make a function that sends files off
individually with a small wait in between. Say we have a vector called
<code>big_batch</code> containing thousands of filenames. First we would
make a function like this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>process_slowly <span class="ot">&lt;-</span> <span class="cf">function</span>(file) {</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>  <span class="fu">dai_async</span>(file)</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>  <span class="fu">Sys.sleep</span>(<span class="dv">10</span>)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>}</span></code></pre></div>
<p>Then we would iterate it over our file vector:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="do">## NOT RUN</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="fu">map</span>(big_batch, process_slowly)</span></code></pre></div>
<p>This will hold up your console for a while, so it may be worth doing
in the background as an RStudio <a href="https://posit.co/blog/rstudio-1-2-jobs/">job</a>.</p>
<p>Finding the optimal wait time for <code>Sys.sleep()</code> may
require some trial and error. As a rule of thumb, it should approximate
the time it takes for DAI to process <em>one</em> of your files. This,
in turn, depends on the size of the files, for a 100-page pdf will take
a lot longer to process than a single-page one. In my experience, a
10-second interval is ample time for a batch of single-page PDFs.
Multi-page pdfs require proportionally more time. If your files vary in
size, calibrate the wait time to the largest file, or you may get 429s
(HTTP code for “rate limit exceeded”) half way through the
iteration.</p>
<p>Although this procedure is relatively slow, it need not add much to
the overall processing time. DAI starts processing the first files it
receives right away, so when your loop ends, DAI will be mostly done
with the OCR as well.</p>
</div>
<div id="merging-shards" class="section level1">
<h1>Merging shards</h1>
<p>If you have long PDFs, DAI will break the output into shards, meaning
that, for a single PDF file, you may get back multiple JSON files named
<code>*-1.json</code>, <code>*-2.json</code>, etc.</p>
<p>To weave the text back together again, you can use
<code>daiR</code>’s <code>merge_shards()</code> function. It works on
<code>.txt</code> files, not JSON files, so you need to extract the text
from the JSONs first. You also need to keep the name stem – turning
<code>document-1.json</code> into <code>document-1.txt</code> and so
forth – so that <code>merge_shards()</code> knows which pieces belong
together. This is the default behaviour of <code>get_text()</code>, so
as long as you don’t touch the <code>outfile_stem</code> parameter, you
should be fine.</p>
<p>Here is a sample workflow:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="do">## NOT RUN</span></span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>shards <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;longdoc-1.json&quot;</span>, <span class="st">&quot;longdoc-2.json&quot;</span>, <span class="st">&quot;longdoc-3.json&quot;</span>)</span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a><span class="fu">map</span>(shards, <span class="sc">~</span> <span class="fu">get_text</span>(.x, <span class="at">type =</span> <span class="st">&quot;async&quot;</span>, <span class="at">save_to_file =</span> <span class="cn">TRUE</span>)</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a><span class="fu">merge_shards</span>()</span></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
